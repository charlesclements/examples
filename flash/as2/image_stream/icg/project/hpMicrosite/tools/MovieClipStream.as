import flash.filters.DisplacementMapFilter;import flash.display.BitmapData;import flash.geom.Point;import flash.geom.Matrix;class icg.project.hpMicrosite.tools.MovieClipStream extends MovieClip{	/*	Variables	*/	// MovieClips	private var mcContainer:MovieClip;	private var mcHolder:MovieClip;	private var mcMap:MovieClip;	private var mcStartPointClip:MovieClip;	private var mcEndPointClip:MovieClip;	// BitmapData	var bpmDisplacement:BitmapData;	// Numbers	private var numInterval:Number;	private var numIntervalSpeed:Number;	private var numIncrement:Number;	private var numIncrementTarget:Number;	private var numStartX:Number;	private var numStartY:Number;	private var numEndX:Number;	private var numEndY:Number;	private var numDistanceX:Number;	private var numDistanceY:Number;	private var numDistanceScale:Number;	private var numDistanceXTraveled:Number;	private var numDistanceYTraveled:Number;	private var numIncrementX:Number;	private var numIncrementY:Number;	private var numIncrementScale:Number;	private var numSpeed:Number;	private var numWaveHeight:Number;	private var numWaveWidth:Number;	private var numXscale:Number;	private var numXskew:Number;	private var numYskew:Number;	private var numYscale:Number;	private var numStartScale:Number;	private var numEndScale:Number;	private var numMinStartScale:Number;	private var numMaxStartScale:Number;	private var numRotationRange:Number;	private var numRotationRangeMinimum:Number;	private var numRotationRangeMaximum:Number;	private var numRotationSpeed:Number;	private var numSpacer:Number;	private var numSpacerMinimum:Number;	private var numSpacerMaximum:Number;	private var numCurrentIndex:Number;	private var numTotal:Number;	private var numSinePositionLast:Number;	private var numSinePositionCurrent:Number;	private var numSinePositionDifference:Number;	private var numXPos:Number;	private var numWaveAngle:Number;	private var numWaveAmplitude:Number;	private var numWaveSpeed:Number;	private var numSkewRangeX:Number;	private var numSkewRangeY:Number;	private var numLayoutIncrement:Number;	// Strings	private var strDirection:String;	private var strHolderName:String;	private var strMapName:String;	// Arrays	private var arrMovieClips:Array;	private var arrTotalMovieClips:Array;	/*	Constrructor	*/	public function MovieClipStream ()	{	}	/*	Setup. Pass the Object into this containing all the variables.	*/	public function setup ($obj:Object):Void	{		this.mcContainer = $obj.container;		// standard DisplacementMap name inside of each attached MovieClip		this.strMapName = $obj.displacementMapMovieClipName;		// determines how far the layout goes		this.numLayoutIncrement = 300;		// speed		this.numSpeed = $obj.speed;		// X and Y		this.numStartX = $obj.startX;		this.numStartY = $obj.startY;		this.numEndX = $obj.endX;		this.numEndY = $obj.endY;		this.mcStartPointClip = $obj.startPointClip;		this.mcEndPointClip = $obj.endPointClip;		// skew stuff		this.numSkewRangeX = $obj.skewRangeX;		this.numSkewRangeY = $obj.skewRangeY;		// matrix stuff		this.numXscale = 1;		this.numXskew = 0;		this.numYskew = 0;		this.numYscale = 1;		// scale		this.numMinStartScale = $obj.startScaleMinimum;		this.numMaxStartScale = $obj.startScaleMaximum;		this.numEndScale = $obj.endScale;		// wave stuff		this.numWaveAngle = $obj.waveAngle;		this.numWaveAmplitude = $obj.waveAmplitude;		this.numWaveSpeed = $obj.waveSpeed;		this.numWaveWidth = $obj.waveWidth;		// rotation		this.numRotationRangeMinimum = $obj.rotationRangeMinimum;		this.numRotationRangeMaximum = $obj.rotationRangeMaximum;		// spacing		this.numSpacerMinimum = $obj.spacerMinimum;		this.numSpacerMaximum = $obj.spacerMaximum;		this.numIntervalSpeed = 30;		this.numCurrentIndex = 0;		this.numIncrement = -1;		this.numIncrementTarget = 0;		this.numTotal = $obj.total;		// Arrays		this.arrMovieClips = $obj.movieClips;		this.arrTotalMovieClips = [];	}	/*	Public: Call this to start running everything.	*/	public function start ():Void	{		this.stop ();		this.numInterval = setInterval (this, "run", this.numIntervalSpeed);		this.startAnime ();	}	/*	Calls all major functions.	*/	private function run ():Void	{		this.timedAttach ();		this.commandAllClips ();		updateAfterEvent ();		this.numIncrement++;	}	/*	Calculates the period of time a new MovieClip should be attached.	*/	private function timedAttach ():Void	{		if (this.numTotal > this.arrTotalMovieClips.length)		{			if (this.numIncrement >= this.numIncrementTarget)			{				// attach MovieClip to container  				this.plugInFunctions (this.attach ());				// randomize spacer				this.numSpacer = this.randRange (this.numSpacerMinimum, this.numSpacerMaximum);				this.numIncrementTarget = this.numIncrementTarget + this.numSpacer;			}		}		else if (this.numTotal == undefined)		{			if (this.numIncrement >= this.numIncrementTarget)			{				// attach MovieClip to container  				this.plugInFunctions (this.attach ());				// randomize spacer				this.numSpacer = this.randRange (this.numSpacerMinimum, this.numSpacerMaximum);				this.numIncrementTarget = this.numIncrementTarget + this.numSpacer;			}		}	}	/*	Attaches MovieClip.	*/	private function attach ():MovieClip	{		var numLevel = this.mcContainer.getNextHighestDepth ();		// get item from Array		var strItem:String = loopArray ();		// attach MovieClip to container        		var mcClip:MovieClip = this.mcContainer.attachMovie (strItem, strItem + numLevel, numLevel, {_x:this.mcStartPointClip._x, _y:this.mcStartPointClip._y});		this.mcMap = mcClip[strMapName];		this.arrTotalMovieClips.push (mcClip);		return (mcClip);	}	/*	Loops thru the Array of available MovieClips and returns the following MovieClip.	Loop starts from the beginning once it reaches the end.	*/	public function loopArray ():String	{		if (this.numCurrentIndex == this.arrMovieClips.length - 1)		{			this.numCurrentIndex = 0;		}		else		{			this.numCurrentIndex++;		}		return this.arrMovieClips[this.numCurrentIndex];	}	/*	Plugs in the necessary variables and functions into each MovieClip for animating.	*/	private function plugInFunctions ($clip:MovieClip):Void	{		// X and Y		this.numDistanceXTraveled = 0;		this.numDistanceYTraveled = 0;		this.numXPos = this.mcStartPointClip._x;		$clip.numDistanceX = this.numDistanceX;		$clip.numDistanceY = this.numDistanceY;		$clip.numDistanceXTraveled = this.numDistanceXTraveled;		$clip.numDistanceYTraveled = this.numDistanceYTraveled;		$clip.numIncrementX = this.numIncrementX;		$clip.numIncrementY = this.numIncrementY;		$clip.numXPos = this.mcStartPointClip._x;		$clip.mcStartPointClip = this.mcStartPointClip;		$clip.mcEndPointClip = this.mcEndPointClip;		// speed		$clip.numSpeed = this.randRange (this.numSpeed * .7, this.numSpeed);		// wave		$clip.numWaveAngle = this.randRange (-this.numWaveAngle, this.numWaveAngle);		$clip.numWaveAmplitude = this.randRange (2, this.numWaveAmplitude);		$clip.numWaveSpeed = this.numWaveSpeed;		$clip.numSinePositionLast = this.numSinePositionLast;		$clip.numSinePositionCurrent = this.numSinePositionCurrent;		$clip.numSinePositionDifference = this.numSinePositionDifference;		// rotation		var arrDirections:Array = ["PLUS", "MINUS"];		var strRotationDirection:String = arrDirections[Math.floor (Math.random () * arrDirections.length)];		switch (strRotationDirection)		{		case "PLUS" :			$clip.numRotationSpeed = this.numRotationSpeed = this.randRange (this.numRotationRangeMinimum, this.numRotationRangeMaximum);			break;		case "MINUS" :			$clip.numRotationSpeed = this.numRotationSpeed = this.randRange ((this.numRotationRangeMinimum) * -1, (this.numRotationRangeMaximum) * -1);			break;		default :			$clip.numRotationSpeed = this.numRotationSpeed = this.randRange (this.numRotationRangeMinimum, this.numRotationRangeMaximum);			break;		}		// randomize frame to start		var numDifferentFrame:Number = Math.ceil (Math.random () * $clip.mcMap._totalframes);		$clip.mcMap.gotoAndPlay (numDifferentFrame);		// skew stuff		$clip.numSkewRangeX = Math.random () * this.numSkewRangeX;		$clip.numSkewRangeY = Math.random () * this.numSkewRangeY;		arrDirections = ["PLUS", "MINUS"];		$clip.strDirection = this.strDirection = arrDirections[Math.floor (Math.random () * arrDirections.length)];		// matrix stuff		$clip.numXscale = this.numXscale;		$clip.numXskew = this.numXskew;		$clip.numYskew = this.numYskew;		$clip.numYscale = this.numYscale;		// scale: currently scale doesnt change, it stays at one size		this.numDistanceScale = this.numEndScale - this.numStartScale;		this.numIncrementScale = this.numDistanceScale / this.numSpeed;		this.numStartScale = this.randRange (this.numMinStartScale, this.numMaxStartScale);		$clip.numStartScale = this.numStartScale;		$clip.numEndScale = this.numEndScale;		$clip.numDistanceScale = this.numDistanceScale;		$clip.numIncrementScale = this.numIncrementScale;		$clip._xscale = $clip._yscale = this.numStartScale;		// array of clips		$clip.arrTotalMovieClips = this.arrTotalMovieClips;		// BitmapData stuff		$clip.mcMap = this.mcMap;		var bpmDisplacement:BitmapData = new BitmapData ($clip.mcMap._width, $clip.mcMap._height, true);		$clip.bpmDisplacement = bpmDisplacement;		var dpmFilter:DisplacementMapFilter = new DisplacementMapFilter (bpmDisplacement, new Point (0, 0), 4, 4, 5, 15, "clamp");		$clip.filters = [dpmFilter];		// functions		$clip.doTween = this.doTween;		$clip.crunchVars = this.crunchVars;		$clip.getSkewIncrement = this.getSkewIncrement;	}	/*	Tells all the clips to run their own functions.	*/	private function commandAllClips ():Void	{		for (var a:Number = 0; a < this.arrTotalMovieClips.length; a++)		{			this.arrTotalMovieClips[a].doTween ();		}	}	/*	Checks whether or not the clip should tween or be removed.	*/	private function doTween ():Void	{		if (Math.abs (this.numDistanceXTraveled) <= Math.abs (Math.round (this.numDistanceX)))		{			this.crunchVars ();		}		else		{			this.removeMovieClip ();		}	}	/*	This does the number crunching for the variables.	*/	private function crunchVars ():Void	{		this.numDistanceX = this.mcEndPointClip._x - this.mcStartPointClip._x;		this.numDistanceY = this.mcEndPointClip._y - this.mcStartPointClip._y;		this.numIncrementX = this.numDistanceX / this.numSpeed;		this.numIncrementY = this.numDistanceY / this.numSpeed;		this.numXPos += this.numIncrementX;		var numX:Number = this._x + this.numIncrementX;		var numY:Number = this._y + this.numIncrementY;		// Wave stuff		var numSineY = numY + Math.sin (this.numWaveAngle) * this.numWaveAmplitude;		var numSineRotation = numY + Math.sin (this.numWaveAngle) * this.numWaveAmplitude;		this.numWaveAngle += this.numWaveSpeed;		// Check to see the distance travelled for purposes of removing the MovieClip.		this.numDistanceXTraveled += this.numIncrementX;		this.numDistanceYTraveled += this.numIncrementY;		// matrix stuff		this.numXskew += this.getSkewIncrement (.02);		var mtx:Matrix = new Matrix (this.numXscale, this.numXskew, this.numYskew, this.numYscale, this.numXPos, numSineY);		this.transform.matrix = mtx;		// rotation outside of matrix		this._rotation += this.numRotationSpeed;		// displacement stuff		this.bpmDisplacement.draw (this.mcMap);	}	/*	--- not working properly yet, skew being thrown off by rotation ---	Returns a positive or negative number to skew by.	*/	private function getSkewIncrement ($num):Number	{		var numSkewIncrement:Number = $num;		switch (this.strDirection)		{		case "PLUS" :			if (this.numXskew < this.numSkewRangeX)			{				numSkewIncrement *= 1;				this.numXskew += numSkewIncrement;			}			else			{				this.strDirection = "MINUS";			}			break;		case "MINUS" :			if (this.numXskew > -this.numSkewRangeX)			{				numSkewIncrement *= -1;				this.numXskew += numSkewIncrement;			}			else			{				this.strDirection = "PLUS";			}			break;		}		return numSkewIncrement;	}	/*	Call this if you want the stream to already be in progess and not start from the beginning.	Pass the optional Boolean param $stream : true - keep moving, false - stopped completely.	*/	public function layout ($stream:Boolean):Void	{		for (var a:Number = 0; a < this.numLayoutIncrement; a++)		{			this.run ();		}		this.stop ();		if ($stream)		{			this.start ();		}	}	/*	Returns a number within a range from a minimum number to a maximum number.	*/	private function randRange ($min:Number, $max:Number):Number	{		var randomNum:Number = Math.floor (Math.random () * ($max - $min + 1)) + $min;		return randomNum;	}	/*	--- currently not used ---	Resets all variables.	*/	public function reset ():Void	{	}	/*	Stop stream completely.	*/	public function stop ():Void	{		clearInterval (this.numInterval);		this.stopAnime ();	}	/*	Starts fluttering animation.	*/	private function startAnime ():Void	{		for (var a:Number = 0; a < this.arrTotalMovieClips.length; a++)		{			this.arrTotalMovieClips[a].mcMap.play ();		}	}	/*	Stops fluttering animation.	*/	private function stopAnime ():Void	{		for (var a:Number = 0; a < this.arrTotalMovieClips.length; a++)		{			this.arrTotalMovieClips[a].mcMap.stop ();		}	}}