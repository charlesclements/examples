/** * VERSION: 0.6 * DATE: 2010-08-19 * AS3 * http://www.greensock.com *  * Copyright 2010, GreenSock. All rights reserved. This work is subject to the terms in <a href="http://www.greensock.com/terms_of_use.html">http://www.greensock.com/terms_of_use.html</a> or for corporate Club GreenSock members, the software agreement that was issued with the corporate membership. **/package com.imt.framework.plugin.slideshow {	import com.bedrock.framework.core.dispatcher.BedrockDispatcher;	import com.greensock.BlitMask;	import com.greensock.TweenLite;	import com.greensock.TweenMax;	import com.greensock.easing.Strong;	import com.greensock.events.LoaderEvent;	import com.greensock.loading.ImageLoader;	import com.greensock.loading.LoaderMax;	import com.greensock.loading.XMLLoader;	import com.greensock.loading.display.ContentDisplay;	import com.greensock.plugins.AutoAlphaPlugin;	import com.greensock.plugins.ColorTransformPlugin;	import com.greensock.plugins.GlowFilterPlugin;	import com.greensock.plugins.ThrowPropsPlugin;	import com.greensock.plugins.TweenPlugin;	import com.imt.framework.plugin.slideshow.Slide;	import com.imt.mch.TeleMedicineCommandCenter.data.AppData;	import com.imt.mch.TeleMedicineCommandCenter.event.MapEvent;		import flash.display.Bitmap;	import flash.display.DisplayObject;	import flash.display.MovieClip;	import flash.display.Shape;	import flash.display.Sprite;	import flash.events.Event;	import flash.events.MouseEvent;	import flash.geom.Rectangle;	import flash.system.Capabilities;	import flash.utils.getTimer;
			public class Slideshow extends MovieClip 	{				public static var THUMB_ORIGINAL_SCALE:Number = 1;		private static var _THUMB_WIDTH:Number = 100;		private static var _THUMB_HEIGHT:Number = 64;		private static var _IMAGE_WIDTH:Number = 550;		private static var _IMAGE_HEIGHT:Number = 355;		private static var _THUMB_GAP:Number = 4;		private static var _SCROLL_SPEED:Number = 12;		private static var _SCROLL_AREA:Number = 150;		private var _box:Box = new Box;		private var _resizeTween:TweenMax;		private var _progressBar:MovieClip;		private var _slides:Array;		private var _curSlide:Slide; //Slide that is currently displaying		private var _loadingSlide:Slide; //only used when a Slide is supposed to show but hasn't been fully loaded yet (like if the user clicks "next" many times before all the images have loaded). We keep track of the one that's in the process of loading and should be shown as soon as it finishes, then we set _loadingSlide back to null.		private var _imagesContainer:Sprite; //the Sprite into which the full-size images are placed (this helps manage the stacking order so that the images can always be behind everything else and yet we can addChild() each image so that it shows up on top of the previous one)		private var _destScrollX:Number = 0; //destination x value for the _thumbnailsContainer which is used for scrolling it across the bottom. We don't want to use _thumbnailsContainer.x because it could be in the process of tweening, so we keep track of the end/destination value and add/subtract from it when creating our tweens.		private var _minScrollX:Number; //we know the maximum x value for _thumbnailsContainer is 0, but the mimimum value will depend on how many thumbnail images it contains (the total width). We calculate it in the _setupThumbnails() method and store it here for easier/faster scrolling calculations in the _enterFrameHandler()		public var bounds:Rectangle;		public var thumbnailsContainer:Sprite; //the Sprite into which the thumbnail images are placed. This also allows us to slide them all at the same time. 		public var blitMask:BlitMask;				public var blitMaskMask:DisplayObject;				private var t1:uint, t2:uint, x1:Number, y1:Number, x2:Number, y2:Number, xOverlap:Number, yOverlap:Number, yOffset:Number, xOffset:Number;						public function Slideshow() 		{						super();						//TweenPlugin.activate( [ ThrowPropsPlugin ] );						//activate the plugins that we'll be using so that TweenLite can tween special properties like filters, colorTransform, and do autoAlpha fades.			//TweenPlugin.activate([ AutoAlphaPlugin, ColorTransformPlugin, GlowFilterPlugin, ThrowPropsPlugin ]);					}						public function initialize():void		{						trace(this + " : initialize()");			_THUMB_WIDTH = 1780;//parent.width;			_THUMB_HEIGHT = 640;//parent.height;			bounds = new Rectangle( 0, 0, _THUMB_WIDTH, _THUMB_HEIGHT );			_progressBar = this.getChildByName("progress_mc") as MovieClip;			thumbnailsContainer = new Sprite();			addChild(thumbnailsContainer);			thumbnailsContainer.y = 0;//_IMAGE_HEIGHT;			_imagesContainer = new Sprite();			var xmlLoader:XMLLoader = new XMLLoader( getImagesXmlUrl(), { onComplete:_xmlCompleteHandler });			xmlLoader.load();					}						public function refresh():void		{						// Accommodate for resizing.			stage.addEventListener( Event.RESIZE, resizing );			// in case image is selected.			parent.parent.addChild( _imagesContainer  );					}				public function clear():void		{						// Accommodate for resizing.			stage.removeEventListener( Event.RESIZE, resizing );			// Remove the child if it exists.			if( parent.parent.contains( _imagesContainer ) ) parent.parent.removeChild( _imagesContainer  );					}						// Handle the resizing event.		private function resizing($e:Event):void		{						//trace(this + " : resizing");			if( contains( thumbnailsContainer ) )			{								removeChild( thumbnailsContainer );				_resizeTween = new TweenMax( {}, 0.3, { onComplete:_postResize } );							}					}						// This is called at a defined time after the resize has finished.		private function _postResize():void		{						//trace(this + " : _postResize");			TweenMax.fromTo( this, 0.7, { colorTransform:{ tint:0xFFFFFF, tintAmount:1 }, immediateRender:true }, { colorTransform:{ tint:0xFFFFFF, tintAmount:0 }, overwrite:1, onComplete:_onPostResizeComplete } );			addChild(thumbnailsContainer);					}						// Called when page has finished transforming after a resize.		private function _onPostResizeComplete():void		{						//trace(this + " : _onPostResizeComplete");					}						private function _xmlCompleteHandler(event:LoaderEvent):void 		{						trace( this + " : _xmlCompleteHandler" )						_slides = [];			var xml:XML = event.target.content; //the XMLLoader's "content" is the XML that was loaded. 			var imageList:XMLList = xml.image; //In the XML, we have <image /> nodes with all the info we need.			//loop through each <image /> node and create a Slide object for each.			for each (var image:XML in imageList) {				_slides.push( new Slide(image.@name,										image.@description,										new ImageLoader ( getImagePath() + "thumbnails/" + image.@name + ".jpg", {name:image.@name + "Thumb", width:_THUMB_WIDTH, height:_THUMB_HEIGHT, scaleMode:"proportionalInside", vAlign:"top", bgColor:0x000000, smooting:true, estimatedBytes:13000, onFail:_imageFailHandler}),										new ImageLoader( getImagePath() + "images/" + image.@name + ".jpg", {name:image.@name + "Image", width:_IMAGE_WIDTH, height:_IMAGE_HEIGHT, scaleMode:"proportionalInside", bgColor:0x000000, smooting:true, estimatedBytes:820000, onFail:_imageFailHandler}) 										)							);			}						//now create a LoaderMax queue and populate it with all the thumbnail ImageLoaders as well as the very first full-size ImageLoader. We don't want to show anything until the thumbnails are done loading as well as the first full-size one. After that, we'll create another LoaderMax queue containing the rest of the full-size images that will load silently in the background.			var initialLoadQueue:LoaderMax = new LoaderMax({onComplete:_initialLoadComplete, onProgress:_progressHandler});			for (var i:int = 0; i < _slides.length; i++) {				initialLoadQueue.append( _slides[i].thumbnailLoader );			}			initialLoadQueue.append(_slides[0].imageLoader); //make sure the very first full-sized image is loaded initially too.			initialLoadQueue.load();						//_setupThumbnails();		}						private function _initialLoadComplete(event:LoaderEvent):void 		{						trace( this + " : _initialLoadComplete" )						//now that the initial load is complete, fade out the progressBar. autoAlpha will automatically set visible to false once alpha hits 0. 			TweenLite.to(_progressBar, 0.5, {autoAlpha:0});						//fade in the thumbnails container			//TweenLite.to(_thumbnailsContainer, 1, {autoAlpha:1});						// Layout the thumbnails AFTER they have been loaded.			_setupThumbnails();						//now put all the remaining images into a LoaderMax queue that will load them one-at-a-time in the background in the proper order. This can greatly improve the user's experience compared to loading them on demand which forces the user to wait while the next image loads.			var imagesQueue:LoaderMax = new LoaderMax({maxConnections:1});			for (var i:int = 1; i < _slides.length; i++) {				imagesQueue.append( _slides[i].imageLoader );			}			imagesQueue.load();						//now start the slideshow			_showNext(null);					}						//loops through all the thumbnail images and places them in the proper order across the bottom of the screen and adds CLICK_THUMBNAIL listeners.		private function _setupThumbnails():void 		{						var l:int = _slides.length;			//var curX:Number = _THUMB_GAP;			for (var i:int = 0; i < l; i++) 			{								// Slide				var s:Slide = _slides[i] as Slide;				s.addEventListener(Slide.CLICK_THUMBNAIL, _clickThumbnailHandler, false, 0, true);				var thumbnail:ContentDisplay = s.thumbnail as ContentDisplay;				thumbnail.fitHeight = ( ( thumbnail as ContentDisplay ).rawContent as Bitmap ).height;				thumbnail.fitWidth = ( ( thumbnail as ContentDisplay ).rawContent as Bitmap ).width;				thumbnail.height = Slideshow._THUMB_HEIGHT;				thumbnail.scaleX = thumbnail.scaleY;				thumbnail.x = thumbnailsContainer.width;				thumbnail.y = 0;				// Darken.				//TweenLite.to(thumbnail, 0, {colorTransform:{brightness:0.5}});				// Add to stage.				thumbnailsContainer.addChild(thumbnail);				//curX += _THUMB_WIDTH + _THUMB_GAP;				//curX += _thumbnailsContainer.width + _THUMB_GAP;			}			// Blitmask stuff.			blitMask = new BlitMask( thumbnailsContainer, bounds.x, bounds.y, bounds.width, bounds.height, true, true, 0x00000000 );//, true						//blitMask.height						blitMask.bitmapMode = false;			blitMask.addEventListener(MouseEvent.MOUSE_DOWN, mouseDownHandler);						blitMaskMask = blitMask.mask;											}						function mouseDownHandler(event:MouseEvent):void 		{						var mc:Sprite = thumbnailsContainer;			TweenLite.killTweensOf(mc);			// X property stuff.			x1 = x2 = mc.x;			xOffset = this.mouseX - mc.x;			xOverlap = Math.max( 0, mc.width - bounds.width );			// Timer stuff.			t1 = t2 = getTimer();			mc.stage.addEventListener(MouseEvent.MOUSE_MOVE, mouseMoveHandler);			mc.stage.addEventListener(MouseEvent.MOUSE_UP, mouseUpHandler);		}						function mouseMoveHandler(event:MouseEvent):void 		{						blitMask.bitmapMode = true;						var mc:Sprite = thumbnailsContainer;			var x:Number = this.mouseX - xOffset;			//var y:Number = this.mouseY - yOffset;									//if mc's position exceeds the bounds, make it drag only half as far with each mouse movement (like iPhone/iPad behavior)			if (x > bounds.left) {				mc.x = (x + bounds.left) * 0.5;			} else if ( x < bounds.left - xOverlap) {				mc.x = (x + bounds.left - xOverlap) * 0.5;			} else {				mc.x = x;			}			blitMask.update();			var t:uint = getTimer();			//if the frame rate is too high, we won't be able to track the velocity as well, so only update the values 20 times per second			if (t - t2 > 50) 			{								x2 = x1;				t2 = t1;				x1 = mc.x;				t1 = t;							}			event.updateAfterEvent();					}						function mouseUpHandler(event:MouseEvent):void 		{						var mc:Sprite = thumbnailsContainer;			mc.stage.removeEventListener(MouseEvent.MOUSE_UP, mouseUpHandler);			mc.stage.removeEventListener(MouseEvent.MOUSE_MOVE, mouseMoveHandler);			var time:Number = (getTimer() - t2) / 1000;						var xVelocity:Number = (mc.x - x2) / time;			ThrowPropsPlugin.to(mc, { onComplete:onThrowComplete, throwProps:{				x:{ velocity:xVelocity, max:0, min:-xOverlap, resistance:300 }//bounds.left - xOverlap			}, onUpdate:blitMask.update, ease:Strong.easeOut			}, 5, 0.3, 1 );//  					}				private function onThrowComplete(event:Event=null):void 		{						blitMask.bitmapMode = false;					}						private function _showNext(event:Event=null):void {			//if there's a _loadingSlide we should assume that the next Slide would be AFTER that one. Otherwise just get the one after the _curSlide.			var next:int = (_loadingSlide != null) ? _slides.indexOf(_loadingSlide) + 1 : _slides.indexOf(_curSlide) + 1;			if (next >= _slides.length) {				next = 0;			}			_requestSlide(_slides[next]);		}						private function _showPrevious(event:Event=null):void {			//if there's a _loadingSlide we should assume that the previous Slide would be BEFORE that one. Otherwise just get the one before the _curSlide.			var prev:int = (_loadingSlide != null) ? _slides.indexOf(_loadingSlide) - 1 : _slides.indexOf(_curSlide) - 1;			if (prev < 0) {				prev = _slides.length - 1;			}			_requestSlide(_slides[prev]);		}						private function _requestSlide(slide:Slide):void 		{						trace("_requestSlide")			if (slide == _curSlide) {				return;			}			//kill the delayed calls to _showNext so that we start over again with a 5-second wait time. 			TweenLite.killTweensOf(_showNext);			if (_loadingSlide != null) {				_cancelPrioritizedSlide(); //the user must have skipped to another Slide and didn't want to wait for the one that was loading.			}			//if the requested Slide's full-sized image hasn't loaded yet, we need to show the progress bar and wait for it to load.			if (slide.imageLoader.progress != 1) {				_prioritizeSlide(slide);				return;			}			//fade the old Slide and make sure it's not highlighted anymore as the current Slide.			if (_curSlide != null) {				TweenLite.to(_curSlide.image, 0.5, {autoAlpha:0});				_curSlide.setShowingStatus(false);			}			_curSlide = slide;			_curSlide.image.scaleX = _curSlide.image.scaleY = 0.1;			// Add the shape for reference.			var rect:Shape = new Shape;			rect.graphics.drawRect( 0, 0, _curSlide.image.width, _curSlide.image.height );			rect.height = AppData.STAGE_HEIGHT;			var s:uint = rect.scaleY;			rect = null;;			// Fade in the slide			TweenLite.to(_curSlide.image, 0.5, { autoAlpha:1, scale:s }); //fade the image in and make sure visible is true.			// Set status.			_curSlide.setShowingStatus(true); //adds an outline to the image indicating that it's the currently showing Slide.			// Call this to keep looping slides.			//TweenLite.delayedCall(5, _showNext); //create a delayedCall that will call _showNext in 5 seconds.					}						private function _prioritizeSlide(slide:Slide):void {			TweenLite.to(_progressBar, 0.5, {autoAlpha:1}); //show the progress bar			_loadingSlide = slide;			_loadingSlide.imageLoader.addEventListener(LoaderEvent.PROGRESS, _progressHandler);			_loadingSlide.imageLoader.addEventListener(LoaderEvent.COMPLETE, _completePrioritizedHandler);			_loadingSlide.imageLoader.prioritize(true); //when the loader is prioritized, it will jump to the top of any LoaderMax queues that it belongs to, so if another loader is in the process of loading in that queue, it will be canceled and this new one will take over which maximizes bandwidth utilization. Once the _loadingSlide is done loading, the LoaderMax queue(s) will continue loading the rest of their images normally.		}						private function _cancelPrioritizedSlide():void {			TweenLite.to(_progressBar, 0.5, {autoAlpha:0}); //hide the progress bar			_loadingSlide.imageLoader.removeEventListener(LoaderEvent.PROGRESS, _progressHandler);			_loadingSlide.imageLoader.removeEventListener(LoaderEvent.COMPLETE, _completePrioritizedHandler);			_loadingSlide = null;		}						private function _completePrioritizedHandler(event:LoaderEvent):void {			var next:Slide = _loadingSlide; //store it in a local variable first because _cancelPrioritizedSlide() will set _loadingSlide to null.			_cancelPrioritizedSlide();			//_requestSlide(next);		}						private function _progressHandler(event:LoaderEvent):void 		{						_progressBar.progressBar_mc.scaleX = event.target.progress;				}						private function _clickThumbnailHandler(event:Event):void 		{						blitMask.bitmapMode = true;			// Get slide.			var s:Slide = event.target as Slide;			AppData.CURRENT_SLIDE = s;			// Do dispatch.			BedrockDispatcher.dispatchEvent( new MapEvent( MapEvent.SHOW_LOCATION_IMAGE, this ) );					}						/*		private function _rollOverArrowHandler(event:Event):void {			TweenLite.to(event.currentTarget, 0.5, {alpha:1});		}				private function _rollOutArrowHandler(event:Event):void {			TweenLite.to(event.currentTarget, 0.5, {alpha:0});		}		private function _enterFrameHandler(event:Event):void {			if (_thumbnailsContainer.hitTestPoint(this.stage.mouseX, this.stage.mouseY, false)) {				if (this.mouseX < _SCROLL_AREA) {					_destScrollX += ((_SCROLL_AREA - this.mouseX) / _SCROLL_AREA) * _SCROLL_SPEED;					if (_destScrollX > 0) {						_destScrollX = 0;					}					TweenLite.to(_thumbnailsContainer, 0.5, {x:_destScrollX});				} else if (this.mouseX > _IMAGE_WIDTH - _SCROLL_AREA) {					_destScrollX -= ((this.mouseX - (_IMAGE_WIDTH - _SCROLL_AREA)) / _SCROLL_AREA) * _SCROLL_SPEED;					if (_destScrollX < _minScrollX) {						_destScrollX = _minScrollX;					}					TweenLite.to(_thumbnailsContainer, 0.5, {x:_destScrollX});				}			}		}		*/						//if an image fails to load properly, remove it from the slideshow completely including its thumbnail at the bottom.		private function _imageFailHandler(event:LoaderEvent):void {			var slide:Slide;			var i:int = _slides.length;			while (--i > -1) {				slide = _slides[i];				if (event.target == slide.thumbnailLoader || event.target == slide.imageLoader) {					slide.dispose();					_slides.splice(i, 1);					_setupThumbnails();					return;				}			}		}						// Returns the URL to the XML file.		private function getImagesXmlUrl():String		{						return ( Capabilities.playerType == 'External' || Capabilities.playerType == 'Desktop' ) ? "xml/images.xml" : "assets/xml/images.xml";					}						// Returns the URL to the XML file.		private function getImagePath():String		{						return ( Capabilities.playerType == 'External' || Capabilities.playerType == 'Desktop' ) ? "images/" : "assets/images/";					}			}	}