	package com.imt.mch.TeleMedicineCommandCenter.model{	//import com.bedrock.framework.Bedrock;	//import com.bedrock.framework.engine.	import com.bedrock.framework.core.dispatcher.BedrockDispatcher;	import com.bedrock.framework.core.event.GenericEvent;	import com.demonsters.debugger.MonsterDebugger;	import com.imt.mch.TeleMedicineCommandCenter.event.MapEvent;		import flash.events.Event;	import flash.events.IOErrorEvent;	import flash.net.*;	import flash.net.FileFilter;	import flash.net.FileReference;	import flash.net.SharedObject;	import flash.net.URLLoader;	import flash.net.URLRequest;	import flash.net.URLVariables;	import flash.system.Capabilities;	import flash.utils.ByteArray;		import settings.Settings;
	//import com.bedrock.framework.core.dispatcher.BedrockDispatcher;		public class MapStore// extends BedrockDispatcher	{						//private var _so:SharedObject;		private var _url:String;		public var xml:XML;				//This variable is never set or used!		private var xmlFileName:String;						private var _fileRef:FileReference;		//private var _file:File		private var _loader:URLLoader;				public var lastClickX:int = 0;		public var lastClickY:int = 0;				private var _hotspots:Array;				public static var instance:MapStore;						// Constructor.		public function MapStore($singletonEnforcer:SingletonEnforcer)		{			super();		}		public static function getInstance():MapStore		{			if( instance == null ) instance = new MapStore( new SingletonEnforcer() );			return instance;		}						// Initializes class.		public function initialize():MapStore		{						MonsterDebugger.trace( this, "initialize" );			//trace(this + " : initialize");			_hotspots = [];			// Create FileReference.			_fileRef = new FileReference();			// Add listeners.			BedrockDispatcher.addEventListener( MapEvent.REMOVE_LOCATION, onMapHandler );			BedrockDispatcher.addEventListener( MapEvent.LOCATION_ADDED, onMapHandler );			BedrockDispatcher.addEventListener( MapEvent.LOCATION_EDITED, onMapHandler );			BedrockDispatcher.addEventListener( MapEvent.MARKER_POSITIONS_UPDATED, onMapHandler );			BedrockDispatcher.addEventListener( MapEvent.MARKER_MODIFIED, onMapHandler );			BedrockDispatcher.addEventListener( MapEvent.MARKER_SELECTED, onMapHandler );			//BedrockDispatcher.addEventListener( MapEvent.MARKER_CLOSED, onMarkerHandler );			BedrockDispatcher.addEventListener( MapEvent.CLEAR_SHARED_OBJECT, onMapHandler );			// Load XML to get everything going.			loadXML();			return this;					}						// Merges a modified XMLList to locations XML.		private function mergeXML($xmlList:XMLList):void		{						trace(this + " : mergeXML");			var locs:XMLList = ( xml..location as XMLList);			var length:uint = locs.length();			// Loop thru the document.			for(var i:uint = 0; i < length; i++)			{								// Check for a match.				if( locs[ i ].label == $xmlList[ 0 ].label )				{										trace(this + " : mergeXML : Matched!");					locs[ i ] = $xmlList[ 0 ];					saveXMLwithPHP();					BedrockDispatcher.dispatchEvent( new MapEvent( MapEvent.MARKER_REFRESH, this, { xml:xml, xmlList:$xmlList } ) );					break;									}							}					}						// 		private function onXmlReady(e:GenericEvent):void		{						trace(this + " : onXmlReady()")			trace(e.details.xml)			MonsterDebugger.trace( this, e.details.xml );								}						// 		private function onMapHandler(e:GenericEvent):void		{						trace(this + " : onMarkerHandler");						switch( e.type )			{								case MapEvent.MARKER_MODIFIED:					//trace(MapEvent.MARKER_MODIFIED)					mergeXML( e.details.xmlList );					break;								case MapEvent.MARKER_POSITIONS_UPDATED:					//trace(MapEvent.MARKER_POSITIONS_UPDATED)					mergeXML( e.details.xmlList );					break;								case MapEvent.LOCATION_ADDED:					//createNewLocation( e.details ).saveData().dispatchXmlReady();																														// Might need this later. CDC					// Currently trying to make the saving of the XML in the "SaveEditedLocationXML" class.										//createNewLocation( e.details ).saveXMLwithPHP().dispatchXmlReady();																									break;								case MapEvent.LOCATION_EDITED:					mergeXML( e.details.xmlList );					break;								case MapEvent.REMOVE_LOCATION:					xml = e.details.xml;					//saveData().dispatchXmlReady();					saveXMLwithPHP().dispatchXmlReady();					break;								case MapEvent.MARKER_SELECTED:										break;								case MapEvent.MARKER_CLOSED:										break;								case MapEvent.CLEAR_SHARED_OBJECT:					//_so.clear();					break;							}					}						/*				Getter and setter not working here. The XY spot is hard coded in Settings.as				*/		public function setHotspots($arr:Array):void		{						trace(this + " : setHotspots()");			MapStore.getInstance()._hotspots = $arr;					}						public function getHotspots():Array		{						trace(this + " : getHotspots()");			//MapStore.getInstance().hotspots = $arr;						return MapStore.getInstance()._hotspots;		}				// Do setup for SharedObject.		public function dispatchXmlReady():MapStore		{						BedrockDispatcher.dispatchEvent( new MapEvent( MapEvent.XML_READY, this, { xml:xml } ) );			return this;					}						// Do setup for SharedObject.		public function editLocation($o:Object):MapStore		{						trace(this + " : editLocation()");						//trace(_xml); // Returns valid.			trace($o.xml);			trace($o);															xml = $o.xml;						return this;					}						// Do setup for SharedObject.		public function createNewLocation($o:Object):MapStore		{						trace(this + " : createNewLocation()");						// Get last clicked location here.			// Theoretically you can grab the variables from lastClickX and lastClickY in this class,			// but it is being passed directly through the object already.			var X:uint = $o.x;//lastClickX;			var Y:uint = $o.y;//lastClickY;						var tempXML:XML = <location isCurrent="false">				<label></label>				<target x="653" y="346"/>				<center x="717.95" y="408.25"/>				<content x="620" y="450">				  <textline></textline>				</content>				<media></media>			  </location>;						var t:XMLList = new XMLList( tempXML );			t.label = $o.label;			t.target.@x = X;			t.target.@y = Y;			t.center.@x = X;			t.center.@y = Y;			t.content.@x = X;			t.content.@y = Y;			t.content.textline[ 0 ] = $o.textline1;			t.content.textline[ 1 ] = $o.textline2;			t.content.textline[ 2 ] = $o.textline3;						xml.prependChild( t );						return this;					}						// Do setup for SharedObject.		public function update($xml:XML):MapStore		{						trace(this + " : update()");			xml = $xml;						return this;					}				// Do setup for SharedObject.		public function importLocations():MapStore		{						var filter:FileFilter = new FileFilter( "Please import preferred Locations document.", "*.xml" );;			var f:FileReference = _fileRef = new FileReference;			f.addEventListener(Event.SELECT, onReference);			f.addEventListener(Event.CANCEL, onReference);			f.browse( [ filter ] );						return this;					}						//Saving the XML file with the help of a PHP file		public function saveXMLwithPHP():MapStore 		{						trace(this + " : saveXMLwithPHP");			// declaring var xmlcontents String.			var xmlcontents:String = xml.toXMLString();									//trace(xmlcontents);									// declaring var SERVER_PATH String. This is the path for the saving-xml.php.			//var SERVER_PATH:String = "C:/";						// declaring var foldername String. This is the folder container of the saved XML file			var foldername:String = "../xml";						// declaring var filename String. This is the filename of the XML file			var filename:String = "locations.xml";						// declaring var dataPass URLVariables			var dataPass:URLVariables = new URLVariables();						// declaring var urlLoader URLLoader			var urlLoader:URLLoader = new URLLoader();						// declaring var previewRequest URLRequest			// use getSavingXmlUrl() because it runs a special condition to deliver URL.			var previewRequest:URLRequest = new URLRequest( getSavingXmlUrl() );						// i used method "post" in this sample. you can edit this			previewRequest.method = URLRequestMethod.POST;												// Do we need do create a callback here? CDC																		// setting dataPass variables to be passed to PHP			dataPass.filename = filename;			dataPass.xmlcontents = xmlcontents;			dataPass.foldername = foldername;						// passing dataPass data PHP			previewRequest.data = dataPass;			//trace (foldername);			// calling the PHP or loading the PHP			urlLoader.load(previewRequest);					return this;					}						// Called when the FileReference has events launched.		private function onReference(e:Event):void		{						trace(this + " : onReference");						var f:FileReference = e.currentTarget as FileReference;			// Clear listeners.			f.removeEventListener(Event.SELECT, onReference);			f.removeEventListener(Event.CANCEL, onReference);			f.removeEventListener(Event.COMPLETE, onReference);						switch( e.type )			{								case Event.SELECT:										f.removeEventListener(Event.SELECT, onReference);					f.addEventListener(Event.COMPLETE, onReference);					f.load();										break;								case Event.COMPLETE:										f.removeEventListener(Event.COMPLETE, onReference);					xml = new XML( e.currentTarget.data )					BedrockDispatcher.dispatchEvent( new MapEvent( MapEvent.XML_READY, this, { xml:xml } ) );										break;								case Event.CANCEL:										//trace(Event.CANCEL);										break;							}					}						// Checks the XML for updates.		private function loadXML():void		{						trace(this + " : loadXML");			MonsterDebugger.trace( this, "loadXML" );			xml = new XML;			_loader = new URLLoader();			_loader.addEventListener(Event.COMPLETE, onXMLLoaded);			_loader.addEventListener(IOErrorEvent.IO_ERROR, onXMLError);			_loader.load( new URLRequest( getLocationsXmlUrl() ) );						MonsterDebugger.trace( this, _loader );								}						// XML has loaded.		private function onXMLError(e:Event):void		{						MonsterDebugger.trace( this, "onXMLError" );								}								// XML has loaded.		private function onXMLLoaded(e:Event):void		{						trace(this + " : onXMLLoaded");			MonsterDebugger.trace( this, "onXMLLoaded" );						//_so.data.map.xml = _xml =  XML(e.target.data);			xml =  XML(e.target.data);						// Announce the XML is ready for use.			BedrockDispatcher.dispatchEvent( new MapEvent( MapEvent.XML_READY, this, { xml:xml } ) );					}						// Returns the URL to the XML file.		private function getSavingXmlUrl():String		{						return ( Capabilities.playerType == 'External' || Capabilities.playerType == 'Desktop' ) ? "scripts/savingxml.php" : "assets/scripts/savingxml.php";					}				// Returns the URL to the XML file.		private function getLocationsXmlUrl():String		{						return ( Capabilities.playerType == 'External' || Capabilities.playerType == 'Desktop' ) ? "xml/locations.xml" : "assets/xml/locations.xml";					}			}	}internal class SingletonEnforcer{}