package com.imt.mch.TeleMedicineCommandCenter.view.map.interactive.dialogue.location{	import com.bedrock.framework.core.dispatcher.BedrockDispatcher;	import com.demonsters.debugger.MonsterDebugger;	import com.greensock.TimelineMax;	import com.greensock.TweenAlign;	import com.greensock.TweenMax;	import com.imt.framework.display.IDisplay;	import com.imt.mch.TeleMedicineCommandCenter.data.AppData;	import com.imt.mch.TeleMedicineCommandCenter.event.MapEvent;		import flash.display.Sprite;	import flash.events.AsyncErrorEvent;	import flash.events.ErrorEvent;	import flash.events.Event;	import flash.events.HTTPStatusEvent;	import flash.events.IEventDispatcher;	import flash.events.IOErrorEvent;	import flash.events.MouseEvent;	import flash.events.NetStatusEvent;	import flash.events.ProgressEvent;	import flash.events.SecurityErrorEvent;	import flash.net.URLLoader;	import flash.net.URLRequest;	import flash.net.URLRequestMethod;	import flash.net.URLVariables;	import flash.system.Security;	import flash.text.TextField;		import settings.Settings;
		public class LocationInfoView extends Sprite implements IDisplay	{						public var txt1:TextField;		public var txt2:TextField;		public var input1:TextField;		public var input2:TextField;		public var suggestion0:TextField;		public var suggestion1:TextField;		public var suggestion2:TextField;		public var suggestion3:TextField;		public var suggestion4:TextField;		private var suggestionArray:Array;		private var _initTimeline:TimelineMax		private var urlLoader:URLLoader = new URLLoader();		private var autoCompleteXML:XML;		private var loadedURL:String;		private var _details:Object;						public function LocationInfoView()		{						super();					}						public function initialize():IDisplay		{						_details = {};			// Initial setting for the textfields and such.			var t:Number = 0;			var arr:Array = [];			//arr.push( new TweenMax( mcDontUseImages, t, { y:-90, colorTransform:{ tint:0x000000, tintAmount:1 } } ) );			//arr.push( new TweenMax( mediaHandler, t, { y:-90, colorTransform:{ tint:0x000000, tintAmount:1 } } ) );			arr.push( new TweenMax( txt1, t, { autoAlpha:1 } ) );			arr.push( new TweenMax( txt2, t, { autoAlpha:1 } ) );			arr.push( new TweenMax( input1, t, { autoAlpha:0 } ) );			arr.push( new TweenMax( input2, t, { autoAlpha:0 } ) );			_initTimeline = new TimelineMax;			_initTimeline.insertMultiple( arr, 0, TweenAlign.NORMAL );			return null;					}						public function refresh():IDisplay		{						return null;					}						public function start():IDisplay		{						txt1.text = input1.text = AppData.SELECTED_XMLLIST.label;			txt2.text = input2.text = AppData.SELECTED_XMLLIST..textline[ 0 ];			//These are the 5 fields below the initial "show location..." for autocomplete purposes			suggestion0.visible=false;			suggestion1.visible=false;			suggestion2.visible=false;			suggestion3.visible=false;			suggestion4.visible=false;			//placing the above into an array			suggestionArray = [];			suggestionArray.push(suggestion0);			suggestionArray.push(suggestion1);			suggestionArray.push(suggestion2);			suggestionArray.push(suggestion3);			suggestionArray.push(suggestion4);			//initiating listeners for a click event.			var l:uint = suggestionArray.length;			for( var i:uint = 0; i < l; i++ )			{				trace("listening")				suggestionArray[ i ].addEventListener( MouseEvent.CLICK, suggestionClicked );							}			return null;					}				public function intro():IDisplay		{			return null;		}						public function outro():IDisplay		{			return null;		}						public function edit($state:Boolean=true):void		{						if( $state )			{								input1.visible = true;				input2.visible = true;				txt1.visible = false;				txt2.visible = false;				input1.addEventListener(Event.CHANGE, autoCompleteTime);							}			else			{								input1.removeEventListener(Event.CHANGE, autoCompleteTime);				input1.visible = false;				input2.visible = false;				txt1.visible = true;				txt2.visible = true;				_details.xmlList = AppData.SELECTED_XMLLIST as XMLList;				_details.xmlList.label = input1.text;//labelTxt.text;				_details.xmlList.content.textline[ 0 ] = input2.text;				BedrockDispatcher.dispatchEvent( new MapEvent( MapEvent.LOCATION_EDITED, this, _details ) );				txt1.text = input1.text;// = AppData.SELECTED_XMLLIST.label + "\n" + AppData.SELECTED_XMLLIST..textline[ 0 ] ;				txt2.text = input2.text;// = AppData.SELECTED_XMLLIST.label + "\n" + AppData.SELECTED_XMLLIST..textline[ 0 ] ;				// Suggestions.				suggestion0.visible=false;				suggestion1.visible=false;				suggestion2.visible=false;				suggestion3.visible=false;				suggestion4.visible=false;							}					}						public function clear():IDisplay		{						suggestion0.visible=false;			suggestion1.visible=false;			suggestion2.visible=false;			suggestion3.visible=false;			suggestion4.visible=false;			return null;					}						public function destroy():IDisplay		{			return null;		}						public function editAnime():TimelineMax		{						// Do editing tween anime.			var timeline:TimelineMax = new TimelineMax;			var t:Number = Settings.ANIMATION_TIME * 0.8;			//var s:Number = ( 200 / mediaHandler.slideshow.thumbnailsContainer.height );			var arr:Array = [];			arr.push( new TweenMax( txt1, t, { autoAlpha:0 } ) );			arr.push( new TweenMax( txt2, t, { autoAlpha:0 } ) );			arr.push( new TweenMax( input1, t, { autoAlpha:0 } ) );			arr.push( new TweenMax( input2, t, { autoAlpha:0 } ) );			arr.push( new TweenMax( input1, t, { delay:t, autoAlpha:1, overwrite:5 } ) );			arr.push( new TweenMax( input2, t, { delay:t, autoAlpha:1, overwrite:5 } ) );			timeline.insertMultiple( arr, 0, TweenAlign.NORMAL, 0.2 );			return timeline;					}						private function autoCompleteTime(e:Event):void		{			/*MonsterDebugger.trace(this, "autoCompleteTime");			Security.loadPolicyFile("C:/Users/Admin/Documents/GitHub/mch/Telemedicine_Wall_2.0/deploy/crossdomain.xml");			urlLoader = new URLLoader();			urlLoader.addEventListener(Event.COMPLETE , googleLoad );			loadedURL="https://maps.googleapis.com/maps/api/place/autocomplete/xml?input="+input1.text+"&types=establishment&sensor=false&key=AIzaSyCpSvX5QgkVdQiSXHWCtmLitZz0lf2tDb4";			trace (loadedURL)			MonsterDebugger.trace(this, "starting request");			var request:URLRequest = new URLRequest(loadedURL);			MonsterDebugger.trace(this, loadedURL);			MonsterDebugger.trace(this, "request through");			configureListeners(urlLoader);			urlLoader.load(request);*/									// Gonna try grabbing the XML via PHP and see if that fixes everything...hopefully ;_;			//OK this works, the code above is obsolete, I'll probably end up removing it.			//DONT FORGET: might want to switch to a key that belongs to IMT for the google searches, you can tie an acct to it and get more total queries per day this way			//Currently using the key I generated on my personal google acct.						var urlRequest:URLRequest = new URLRequest("http://localhost/Autocomplete.php");			urlRequest.method = URLRequestMethod.POST;						var urlLoader:URLLoader = new URLLoader();			var variables:URLVariables = new URLVariables();			variables.input = input1.text;						urlRequest.data = variables;			//urlLoader.dataFormat = URLLoaderDataFormat.TEXT;			urlLoader.addEventListener(Event.COMPLETE, googleLoad);			urlLoader.load(urlRequest);										}				private function configureListeners(dispatcher:IEventDispatcher):void {			dispatcher.addEventListener(Event.COMPLETE, completeHandler);			dispatcher.addEventListener(Event.OPEN, openHandler);			dispatcher.addEventListener(ErrorEvent.ERROR, onError)			dispatcher.addEventListener(AsyncErrorEvent.ASYNC_ERROR, onAsyncError);			dispatcher.addEventListener(NetStatusEvent.NET_STATUS, onNetStatus);			dispatcher.addEventListener(ProgressEvent.PROGRESS, progressHandler);			dispatcher.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);			dispatcher.addEventListener(HTTPStatusEvent.HTTP_STATUS, httpStatusHandler);			dispatcher.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);		}				// HANDLERS		private function completeHandler(event:Event):void {			MonsterDebugger.trace( this, "completeHandler data: " + event.currentTarget.data);			trace("completeHandler data: " + event.currentTarget.data);		}				private function openHandler(event:Event):void {			MonsterDebugger.trace( this, "openHandler: " + event);			trace("openHandler: " + event);		}		private function onError(event:ErrorEvent):void {			MonsterDebugger.trace( this, "onError: " + event.type);			trace("onError: " + event.type);		}				private function onAsyncError(event:AsyncErrorEvent):void {			MonsterDebugger.trace( this,"onAsyncError: " + event);			trace("onAsyncError: " + event);		}				private function onNetStatus(event:NetStatusEvent):void {			MonsterDebugger.trace( this, "onNetStatus: " + event);			trace("onNetStatus: " + event);		}				private function progressHandler(event:ProgressEvent):void {			MonsterDebugger.trace( this, "progressHandler loaded:" + event.bytesLoaded + " total: " + event.bytesTotal);			trace("progressHandler loaded:" + event.bytesLoaded + " total: " + event.bytesTotal);		}				private function securityErrorHandler(event:SecurityErrorEvent):void {			MonsterDebugger.trace( this, "securityErrorHandler: " + event);			trace("securityErrorHandler: " + event);		}				private function httpStatusHandler(event:HTTPStatusEvent):void {			MonsterDebugger.trace( this, "httpStatusHandler: " + event);			trace("httpStatusHandler: " + event);		}				private function ioErrorHandler(event:IOErrorEvent):void {			MonsterDebugger.trace( this, "ioErrorHandler: " + event);			trace("ioErrorHandler: " + event);		}						private function suggestionClicked(e:Event):void		{						trace("CLICKED!")			txt1.text = input1.text = autoCompleteXML.prediction[0].term[0].value;			var l:uint;			var i:uint;						switch( e.target )			{								case suggestion0:										//input1.text = autoCompleteXML.prediction[0].term[0].value;					txt1.text = input1.text;					input2.text="";										l = autoCompleteXML..prediction[0].term.length();					for( i = 1; i < l; i++ )					{												//input2.text += autoCompleteXML.prediction[0].term[i].value +", ";						input2.appendText( autoCompleteXML.prediction[0].term[i].value +", " );											}										break;								case suggestion1:										input1.text = autoCompleteXML.prediction[1].term[0].value;					txt1.text = input1.text;					input2.text="";										l = autoCompleteXML..prediction[1].term.length();					for( i = 1; i < l; i++ )					{												input2.appendText( autoCompleteXML.prediction[1].term[i].value +", " );											}										break;								case suggestion2:					input1.text = autoCompleteXML.prediction[2].term[0].value;					txt1.text = input1.text;					input2.text="";										l = autoCompleteXML..prediction[2].term.length();					for( i = 1; i < l; i++ )					{												input2.appendText( autoCompleteXML.prediction[2].term[i].value +", " );											}					break;								case suggestion3:										input1.text = autoCompleteXML.prediction[3].term[0].value;					txt1.text = input1.text;					input2.text="";										l = autoCompleteXML..prediction[3].term.length();					for( i = 1; i < l; i++ )					{												input2.appendText( autoCompleteXML.prediction[3].term[i].value +", " );											}										break;								case suggestion4:										input1.text = autoCompleteXML.prediction[4].term[0].value;					txt1.text = input1.text;					input2.text="";										l = autoCompleteXML..prediction[4].term.length();					for( i = 1; i < l; i++ )					{												input2.appendText( autoCompleteXML.prediction[4].term[i].value +", " );											}										break;							}						trace ("settingText")			input2.text= input2.text.substring(0,input2.text.length-2);			txt2.text = input2.text;			suggestion0.visible=false;			suggestion1.visible=false;			suggestion2.visible=false;			suggestion3.visible=false;			suggestion4.visible=false;					}						private function googleLoad(e:Event):void{						var currentOne:TextField;	     	MonsterDebugger.trace (this, "googleLoad");			MonsterDebugger.trace (this, e.target.data);							//generate XML with data grabbed by PHP.			autoCompleteXML = new XML(e.target.data);    			trace (autoCompleteXML..prediction.length())			var i:int =0;						//This decides whether the autocomplete returned 5 or more responses, if less than 5 it will remove some fields so they dont appear empty or full of garbage.			if (autoCompleteXML..prediction.length()<5)			{				trace("if.......")				for (var x:int = 0; x<(autoCompleteXML.prediction.length());x++){					currentOne= new TextField;					currentOne.text= autoCompleteXML.prediction[i].description;					suggestionArray[i].text = currentOne.text;					trace (autoCompleteXML.prediction[i].description)					trace(i)					i++				}				suggestion0.visible=true;				suggestion1.visible=true;				suggestion2.visible=true;				suggestion3.visible=true;				suggestion4.visible=true;				switch (i){					case 0:						trace ("case 0")						suggestion0.visible=false;						suggestion1.visible=false;						suggestion2.visible=false;						suggestion3.visible=false;						suggestion4.visible=false;						break;					case 1: 						trace("case 1")						suggestion1.visible=false;						suggestion2.visible=false;						suggestion3.visible=false;						suggestion4.visible=false;						break;					case 2:						trace("case 2")						suggestion2.visible=false;						suggestion3.visible=false;						suggestion4.visible=false;						break;					case 3:						trace("case 3")						suggestion3.visible=false;						suggestion4.visible=false;						break;					case 4:						trace("case 4")						suggestion4.visible=false;						break;					default:						trace("DEFAULT?!?")						break;				}							}							else				{								trace("else....")				for (i=0; i<5; i++)				{										currentOne= new TextField;					currentOne.text= autoCompleteXML.prediction[i].description;					suggestionArray[i].text = currentOne.text;										//currentOne.x = txt1.x;					//currentOne.y = txt1.y + 30;					//addChild(currentOne);					trace (autoCompleteXML.prediction[i].description)									}				suggestion0.visible=true;				suggestion1.visible=true;				suggestion2.visible=true;				suggestion3.visible=true;				suggestion4.visible=true;							}					}			}	}