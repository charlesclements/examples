package com.imt.mch.TeleMedicineCommandCenter.view.map.interactive.dialogue{		import com.bedrock.framework.core.dispatcher.BedrockDispatcher;	import com.bedrock.framework.plugin.util.ButtonUtil;	import com.greensock.TimelineMax;	import com.greensock.TweenAlign;	import com.greensock.TweenMax;	import com.greensock.easing.Ease;	import com.greensock.easing.Power0;	import com.greensock.easing.Power1;	import com.greensock.layout.AlignMode;	import com.greensock.layout.LiquidArea;	import com.greensock.layout.ScaleMode;	import com.imt.framework.display.IDisplay;	import com.imt.framework.plugin.slideshow.Slide;	import com.imt.mch.TeleMedicineCommandCenter.data.AppData;	import com.imt.mch.TeleMedicineCommandCenter.event.MapEvent;		import flash.display.BitmapData;	import flash.display.Shape;	import flash.display.Sprite;	import flash.events.MouseEvent;
		public class SlideImageDialogue extends Sprite implements IDisplay	{				private var _image:Sprite		private var _holder:Sprite		private var _shape:Shape;		private var _area:LiquidArea;		private var _introTimeline:TimelineMax				public function SlideImageDialogue()		{			super();		}						public function initialize():IDisplay		{						_shape = new Shape;			_holder = new Sprite;			_area = new LiquidArea( this, 0, 0, AppData.STAGE_WIDTH, AppData.STAGE_HEIGHT, 0x313f19, 0, 0, AppData.STAGE_WIDTH, AppData.STAGE_HEIGHT );			return this;					}						public function refresh():IDisplay		{						trace(this + " : refresh" );						_image = ( AppData.CURRENT_SLIDE as Slide ).image;			TweenMax.to( _image, 0, { autoAlpha:0 } );						ButtonUtil.addListeners( _image, { down:onDown } );			addChild( _image );			_area.attach( _image, { scaleMode:ScaleMode.PROPORTIONAL_INSIDE, hAlign:AlignMode.CENTER, vAlign:AlignMode.CENTER } );			_shape.graphics.beginFill( 0x00ff00, 1 );			_shape.graphics.drawRect( 0, 0, _image.width, _image.height );			_shape.graphics.endFill();			_holder.addChild( _shape );			addChild( _holder );						var _blink:Number = 0.07;						// Insert sound queues.							_introTimeline = new TimelineMax( { onReverseComplete:_onOutroComplete } );			var tweens:Array = [];			tweens.push( new TweenMax( _shape, 0, { scale:0.1, x:( _image.width / 2 ) + _image.x, y:( _image.height / 2 ) + _image.y, autoAlpha:1 } ) );			tweens.push( new TweenMax( _shape, 0.15, { x:_image.x, y:_image.y, width:_image.width, height:_image.width, ease:Power0.easeOut } ) );			tweens.push( new TweenMax( _image, 0, { delay:0.1, autoAlpha:1 } ) );			//tweens.push( new TweenMax( _area, 0, { autoAlpha:1 } ) );						tweens.push( new TweenMax( _shape, 0, { delay:_blink, autoAlpha:0 } ) );			tweens.push( new TweenMax( _shape, 0, { delay:_blink, autoAlpha:1 } ) );			tweens.push( new TweenMax( _shape, 0, { delay:_blink, autoAlpha:0 } ) );			tweens.push( new TweenMax( _shape, 0, { delay:_blink, autoAlpha:1 } ) );			tweens.push( new TweenMax( _shape, 0.15, { autoAlpha:0 } ) );			_introTimeline.appendMultiple( tweens, 0, TweenAlign.SEQUENCE );			_introTimeline.pause();						//TweenMax.fromTo( _shape, 0.7, { scale:0.1, x:( _image.width / 2 ) + _image.x, autoAlpha:1 }, { x:_image.x, y:_image.y, width:_image.width, height:_image.width } );						intro();			/*			*/			return this;					}				public function intro():IDisplay		{						trace(this + " : intro" );						_introTimeline.gotoAndPlay( 0 );						return this;					}				private function onDown($e:MouseEvent):void		{						outro();														}				public function start():IDisplay		{			return this;		}						public function outro():IDisplay		{						_introTimeline.reverse();			return this;					}				private function _onOutroComplete():void		{						BedrockDispatcher.dispatchEvent( new MapEvent( MapEvent.SHOW_LOCATION, this, { xmlList:AppData.SELECTED_XMLLIST } ) );					}						public function clear():IDisplay		{						//var s:Sprite = ( AppData.CURRENT_SLIDE as Slide ).image;			ButtonUtil.removeListeners( _image, { down:onDown } );			if( contains( _image ) ) removeChild( _image );			_area.release( _image );						return this;					}						public function destroy():IDisplay		{			return this;		}					}		}