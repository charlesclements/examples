package com.imt.game{			import com.bedrock.extras.util.MathUtil;	import com.bedrock.extras.util.StringUtil;	import com.bedrock.framework.plugin.storage.SuperArray;	import com.bedrock.framework.plugin.util.ArrayUtil;	import com.bedrock.framework.plugin.util.VariableUtil;	import com.demonsters.debugger.MonsterDebugger;	import com.greensock.TimelineMax;	import com.greensock.TweenAlign;	import com.greensock.TweenMax;	import com.greensock.easing.Power4;	import com.greensock.easing.Quad;	import com.imt.assets.Assets;	import com.imt.framework.core.dispatcher.StarlingDispatcher;	import com.imt.framework.display.AbstractStarlingDisplay;	import com.imt.framework.display.IDisplay;	import com.imt.framework.display.button.AbstractButton;	import com.imt.framework.display.button.GameButton;	import com.imt.framework.engine.data.GameData;	import com.imt.framework.event.StarlingSiteEvent;	import com.imt.game.components.Ball;	import com.imt.game.components.Card;	import com.imt.model.Storage;	import com.imt.objects.Armor;	import com.imt.objects.IParticle;	import com.imt.objects.Soul;		import flash.display.Bitmap;	import flash.display.BitmapData;	import flash.events.MouseEvent;	import flash.geom.Rectangle;	import flash.system.ApplicationDomain;	import flash.utils.Dictionary;		import hype.extended.behavior.VariableVibration;	import hype.extended.color.ColorPool;	import hype.extended.trigger.ExitRectangleTrigger;	import hype.extended.trigger.ExitShapeTrigger;	import hype.extended.trigger.ExitStarlingShapeTrigger;	import hype.extended.trigger.SeamlessPlacement;	import hype.framework.core.ObjectPool;	import hype.framework.core.ObjectPoolLayerStarling;	import hype.framework.core.TimeType;	import hype.framework.display.BitmapCanvas;	import hype.framework.rhythm.RhythmManager;	import hype.framework.rhythm.SimpleRhythm;		import starling.core.Starling;	import starling.display.DisplayObject;	import starling.display.DisplayObjectContainer;	import starling.display.Graphics;	import starling.display.Image;	import starling.display.Sprite;	import starling.display.graphics.Graphic;	import starling.events.Event;	import starling.textures.Texture;	import starling.textures.TextureAtlas;			public class GamePlay extends AbstractStarlingDisplay implements IDisplay	{						private var _touchedCards:Array;		private var _sequence:SuperArray;		private var _textures:SuperArray;		private var _cardsDuplicate:Dictionary;		private var COLUMNS:int = 2;		private var PADDING:int = 130;		private var _endWidth:int;		private var _atlas:TextureAtlas;		private var _xml:XML;		private var _alias:String;		private var _cardsHolderTouched:Sprite;		private var _stages:Dictionary;		private var _stageSequences:Dictionary;		private var _currentStage:String;		private var _numActiveParticles:uint = 0;		public static var STAGE_SEQUENCES:Dictionary;		private var _displayTimeline:TimelineMax;		private var _effectsBitmap:Bitmap;		private var _effectsSprite:Sprite;		private var _effectsDisplayContainer:DisplayObjectContainer;		private var _color:ColorPool = new ColorPool( 0xFF5704, 0xE82E03, 0xFF1A10, 0xE80356, 0xFF04DC, 0x645611, 0x20BCBD, 0xB0960C, 0x7D1560, 0xFD05B7, 0xF20530, 0x03A696, 0xF28705, 0xD96704, 0xF2360C );				// Pools.		private var _armorPool:ObjectPoolLayerStarling;		private var _soulsPool:ObjectPoolLayerStarling;						// Hype.		//var bmc:BitmapCanvas;		private var clipContainer:Sprite;						public function GamePlay()		{			super();		}						public function initialize(data:Object=null):void		{						if( !initialized )			{								trace( this + " : initialize" );				_stages = new Dictionary;				_stageSequences = new Dictionary;				_displayTimeline = new TimelineMax;				// Set vars.				_alias = data.alias;				_atlas = data.atlas;				_xml = data.xml;								// Create game.				_createGame();				initialized = true;							}					}						public function refresh():void		{						//trace("");			trace(this + " : refresh()");						// Events.			StarlingDispatcher.addEventListener( StarlingSiteEvent.TIMER_COMPLETE, _onEvent );			StarlingDispatcher.addEventListener( StarlingSiteEvent.PAUSE, _onEvent );			StarlingDispatcher.addEventListener( StarlingSiteEvent.RESUME, _onEvent );						// To reset particle props here.			//_armorPool.refresh();			_soulsPool.refresh();					}						public function clear():void		{						trace(this + " : clear()");						// Events.			StarlingDispatcher.removeEventListener( StarlingSiteEvent.TIMER_COMPLETE, _onEvent );			StarlingDispatcher.removeEventListener( StarlingSiteEvent.PAUSE, _onEvent );			StarlingDispatcher.removeEventListener( StarlingSiteEvent.RESUME, _onEvent );						// Clear animations.			_armorPool.clear();			_soulsPool.clear();					}						public function start():void		{						trace(this + " : start()");			//pool.requestAll();					}						public function intro():void{};						public function outro():void		{						trace(this + " : outro()");						// Calling an outroComplete based on time.			//TweenMax.delayedCall( 1, _onOutroComplete );					}						public function cancel():void{};		public function destroy():void{};						private function _onEvent(event:Event):void		{						trace( this + " _onEvent : " + event.type );						// Reuseable var.			var i:uint;// "for loops".			var clip:Armor;			var length:uint// Used in "for loops".						switch( event.type )			{								case StarlingSiteEvent.TIMER_COMPLETE:					trace( this + " : StarlingSiteEvent.TIMER_COMPLETE" );					_gameComplete();					break;								case StarlingSiteEvent.PAUSE:					trace( this + " : StarlingSiteEvent.PAUSE" );					_displayTimeline.pause();					break;								case StarlingSiteEvent.RESUME:					trace( this + " : StarlingSiteEvent.RESUME" );					_displayTimeline.resume();					break;								case StarlingSiteEvent.TOUCHED:					//_numActiveParticles--;					//clip = event.currentTarget as Armor;					//clip.disable();					//_armorPool.release( clip );					//clipContainer.addChildAt( clip, 0 );					if( _numActiveParticles <= 0 ) _gameComplete();					break;								case starling.events.Event.ADDED_TO_STAGE:					removeEventListener( starling.events.Event.ADDED_TO_STAGE, _onEvent);					initialize();					break;								default:					trace(this + " : Unhandled event.");								}					}						// Creates and builds out game here.		private function _gameComplete():void		{						trace(this + " : _gameComplete()");			StarlingDispatcher.dispatchEvent( new StarlingSiteEvent( StarlingSiteEvent.GAME_COMPLETE ) );			//_clearParticles();			_armorPool.clear();			_soulsPool.clear();					}						// Creates and builds out game here.		private function _createGame():void		{						trace("");			trace(this + " : _createGame()");									_effectsSprite = new Sprite;			addChild( _effectsSprite );						// Armor.			//_armorPool = new ObjectPoolLayerStarling( [ Armor, Soul ], 30 );			_armorPool = new ObjectPoolLayerStarling( Armor, 30 );			addChild( _armorPool );									// Souls.			_soulsPool = new ObjectPoolLayerStarling( Soul, 1 );			_soulsPool.addEventListener( ObjectPoolLayerStarling.REQUESTED, onSoulRequested );			addChild( _soulsPool );					}										// Removes particles in play.		private function onSoulRequested(e:Event):void		{						trace(this + " : onSoulRequested");			trace(e.data);			trace(e.data.clip);									_armorPool.requestSwarm( e.data.clip, 6 );								}										// Removes particles in play.		private function _clearParticles():void		{						_armorPool.clear();			_soulsPool.clear();								}					}			}