package com.imt.objects{			import com.bedrock.extras.util.MathUtil;	import com.imt.model.Storage;		import flash.display.Bitmap;	import flash.display.BitmapData;	import flash.geom.Rectangle;	import flash.utils.Dictionary;		import hype.extended.behavior.MouseFollowEase;	import hype.extended.behavior.MouseFollowStarling;	import hype.extended.behavior.ObjectFollowStarling;	import hype.extended.behavior.VariableVibration;	import hype.extended.trigger.SeamlessPlacement;		import starling.core.starling_internal;	import starling.display.Image;	import starling.textures.Texture;		public class Soul extends AbstractParticle implements IParticle	{					public function Soul()		{						//trace( "Soul" );			/*			// Create soul circle here.			var circle:flash.display.Shape = new flash.display.Shape();			circle.graphics.beginFill(0xffff00, 1);			circle.graphics.drawCircle( 10, 10, 10 );			circle.graphics.endFill();						var bmpData:BitmapData = new BitmapData( 20, 20, false, 0x000000 );			bmpData.draw( circle );			//bmpData.drawWithQuality( circle );						var bm:Bitmap = new Bitmap( bmpData, "auto", true );			*/												super( { id:"soul" }, Texture.fromBitmapData( new BitmapData( 10, 10, true, 0xccff00cc ) ), "" );									var b:Dictionary = _behaviourDictionary;						var key:String = "0";			b[ key ] = [];						//var tempIndex:uint = 0;			b[ key ].push( new VariableVibration( this, "x", 0.99, 0.05, 1.5 ) );			b[ key ].push( new VariableVibration( this, "y", 0.99, 0.05, 1.5 ) );			b[ key ].push( new ObjectFollowStarling( this, Storage.FLASH_STAGE, 0.001 ) );			b[ key ].push( new SeamlessPlacement( this, new Rectangle( 0, 0, Storage.WIDTH, Storage.HEIGHT ) ) );						// Random rotation.			//rotation = MathUtil.degreesToRadians( Math.random() * 360 );									/*						// Stage 1.			_behaviour.push( [] );						var tempIndex:uint = 0;			_behaviour[ tempIndex ].push( new VariableVibration( this, "x", 0.99, 0.05, 1.5 ) );			_behaviour[ tempIndex ].push( new VariableVibration( this, "y", 0.99, 0.05, 1.5 ) );			_behaviour[ tempIndex ].push( new ObjectFollowStarling( this, Storage.FLASH_STAGE, 0.001 ) );			//_behaviour[ stage ].push( new VariableVibration( this, "rotation", 0.99, 0.05, 0.1 ) );			_behaviour[ tempIndex ].push( new SeamlessPlacement( this, new Rectangle( 0, 0, Storage.WIDTH, Storage.HEIGHT ) ) );						// Random rotation.			//rotation = MathUtil.degreesToRadians( Math.random() * 360 );						*/																				}				/*		// Runs behaviour		public function startBehaviour():void		{						//trace( "Soul - startBehaviour" );						// Kill running behaviours.			stopBehaviour();						var b:Dictionary = _behaviourDictionary;			var l:uint = b[ _key ].length;						for( var a:uint = 0; a < l; a++ )			{								b[ _key ][ a ].start();							}					//for( var a:uint = 0; a < _behaviour[ _stageIndex ].length; a++ )			//{								//_behaviour[ _stageIndex ][ a ].start();							//}					}						// Stops behaviour		public function stopBehaviour():void		{						//trace( "Soul - stopBehaviour" );						var l:uint = _behaviour.length;						for( var a:uint = 0; a < l; a++ )			{								for( var b:uint = 0; b < l; b++ )				{										_behaviour[ a ][ b ].stop();									}							}					}		*/						public function reset():void		{						trace( "Soul - reset" );			rotation = MathUtil.degreesToRadians( 0 );					}						public function removeMe():void		{						//trace( "ParticleButton - removeMe" );			parent.removeChild( this );					}						public function setup():void		{						trace( "ParticleButton - setup" );											}					}		}