package hype.framework.core{			import com.greensock.TweenMax;	import com.greensock.easing.Quad;	import com.imt.framework.core.dispatcher.StarlingDispatcher;	import com.imt.framework.display.button.AbstractButton;	import com.imt.framework.event.StarlingSiteEvent;	import com.imt.model.Storage;	import com.imt.objects.AbstractParticle;	import com.imt.objects.Armor;	import com.imt.objects.IParticle;		import starling.display.DisplayObject;	import starling.display.Sprite;	import starling.events.Event;			public class ObjectPoolLayerStarling extends Sprite	{						private var _pool:ObjectPool;		//private var _point:DisplayObject = null;		private var _content:*;		private var _key:String = "";		private var _container:Sprite;				public var requestedObject:Object = null;		public static const REQUESTED:String = "ObjectPoolLayerStarling.REQUESTED";		public static const RELEASED:String = "ObjectPoolLayerStarling.RELEASED";				private var _swarmPoint:DisplayObject = null;						public function ObjectPoolLayerStarling(content:*, max:uint)//, container:Sprite		{						trace( "ObjectPoolLayerStarling" );			super();						_content = content;			_pool = new ObjectPool( _content, max );												_pool.onCreateObject = function(clip:IParticle) 			{								trace(this + " : pool.onCreateObject");							}									_pool.onRequestObject = function(clip:IParticle) 			{								trace("");				trace("");				trace("");				trace("");				trace("");				trace(this + " : pool.onRequestObject");								trace(_key);				trace(_swarmPoint);												//( clip as AbstractParticle ).swarmPoint = _swarmPoint;												( clip as Sprite ).x = Math.random() * Storage.WIDTH;				( clip as Sprite ).y = Math.random() * Storage.HEIGHT;				//( clip as Sprite ).scaleX = ( clip as Sprite ).scaleY = 0.6 + ( Math.floor( Math.random() * 3 ) * 0.6);				( clip as AbstractParticle ).enable();				( clip as Sprite ).addEventListener( StarlingSiteEvent.TOUCHED, _onEvent );				addChild( ( clip as Sprite ) );				//_container.addChild( ( clip as Sprite ) );								( clip as AbstractParticle ).key = "swarm";																clip.startBehaviour();								dispatchEvent( new Event( REQUESTED, false, { clip:clip } ) );							}					}								public function requestSwarm(point:DisplayObject, max:uint = 1):void		{						trace(this + " : requestSwarm()");			_key = "swarm";			_swarmPoint = point;			for( var i:uint = 0; i < max; i++ ) _pool.request();			_swarmPoint = null;					}				/*		public function setSwarmPoint(point:DisplayObject):void		{						_swarmPoint = point;					}						public function requestSwarm(point:DisplayObject):void		{						trace(this + " : requestSwarm()");			_point = point;			_pool.request();					}						public function releaseSwarm(point:DisplayObject):void		{						trace(this + " : releaseSwarm()");											}		*/				public function refresh():void		{						trace(this + " : refresh()");						// Events.			StarlingDispatcher.addEventListener( StarlingSiteEvent.TIMER_COMPLETE, _onEvent );			StarlingDispatcher.addEventListener( StarlingSiteEvent.PAUSE, _onEvent );			StarlingDispatcher.addEventListener( StarlingSiteEvent.RESUME, _onEvent );						// To reset particle props here.			_pool.requestAll();					}						public function clear():void		{						trace(this + " : clear()");			StarlingDispatcher.removeEventListener( StarlingSiteEvent.TIMER_COMPLETE, _onEvent );			StarlingDispatcher.removeEventListener( StarlingSiteEvent.PAUSE, _onEvent );			StarlingDispatcher.removeEventListener( StarlingSiteEvent.RESUME, _onEvent );						// Kill animations here.			_clearParticles();			//_numActiveParticles = 0;					}										private function _onEvent(event:Event):void		{						trace( this + " _onEvent : " + event.type );						// Reuseable var.			var i:uint;// "for loops".			var clip:Armor;			var length:uint// Used in "for loops".						switch( event.type )			{								case StarlingSiteEvent.TIMER_COMPLETE:					trace( this + " : StarlingSiteEvent.TIMER_COMPLETE" );					//_gameComplete();					break;								case StarlingSiteEvent.PAUSE:					trace( this + " : StarlingSiteEvent.PAUSE" );					//_displayTimeline.pause();					break;								case StarlingSiteEvent.RESUME:					trace( this + " : StarlingSiteEvent.RESUME" );					//_displayTimeline.resume();					break;								case StarlingSiteEvent.TOUCHED:					//_numActiveParticles--;					clip = event.currentTarget as Armor;					clip.disable();					_pool.release( clip );					_container.addChildAt( clip, 0 );					//if( _numActiveParticles <= 0 ) _gameComplete();					break;				/*				case starling.events.Event.ADDED_TO_STAGE:					removeEventListener( starling.events.Event.ADDED_TO_STAGE, _onEvent);					initialize();					break;				*/				default:					trace(this + " : Unhandled event.");								}					}								// Removes particles in play.		public function requestAll():void		{						_pool.requestAll();					}							// Removes particles in play.		private function _clearParticles():void		{						trace(this + " : _clearParticles()");						var clip:IParticle;			//var l:uint = clipContainer.numChildren;												_pool.releaseAll();			var l:uint = _pool.inactiveSet.length;						// active						//trace(l);						for( var i:uint = 0; i < l; i++ )			{								//clip = _pool.inactiveSet.pull() as Armor;				clip = _pool.inactiveSet.pull() as IParticle;				_pool.tempSet.insert( clip );								// Run tweening here.				TweenMax.to( ( clip as Sprite ), 1, { scaleX:0.4, scaleY:0.4, x:Storage.WIDTH / 2, y:Storage.HEIGHT / 2, onComplete:clip.removeMe, delay:0.02 * i, ease:Quad.easeIn } );							}						// Place back into inactiveSet.			for( i = 0; i < l; i++ )			{								_pool.inactiveSet.insert( _pool.tempSet.pull() );							}								}					}	}