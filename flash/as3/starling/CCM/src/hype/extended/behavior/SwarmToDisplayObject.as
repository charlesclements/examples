package hype.extended.behavior {	//import flash.display.DisplayObject;	import com.imt.objects.AbstractParticle;		import flash.geom.Point;		import hype.framework.behavior.AbstractBehavior;	import hype.framework.behavior.IBehavior;	import hype.framework.core.HypeMath;		import starling.display.DisplayObject;
	/**	 * Makes the target object chase after a point	 */	public class SwarmToDisplayObject extends AbstractBehavior implements IBehavior 	{				protected var _point:DisplayObject;		protected var _speed:Number;		protected var _turnEase:Number;		protected var _twitch:Number;				/**		 * Constructor		 * 		 * @param target Target object (must have x and y properties)		 * @param point Goal point		 * @param speed Speed the target can travel		 * @param turnEase Percentage the target can rotate toward it's goal in a given step		 * @param twitch Angular range of a random "twitch" added to each movement		 */		public function SwarmToDisplayObject(target:Object, speed:Number, turnEase:Number, twitch:Number) {//point:DisplayObject, 			super(target);						//_point = point;			_speed = speed;			_turnEase = turnEase;			_twitch = twitch;		}				/**		 * @protected		 */		public function run(target:Object):void {									//trace("run ++++++++++++++++");			//if( !_point.x ){ trace("X does); };																					var clip:DisplayObject = target as DisplayObject;						_point = ( clip as AbstractParticle ).swarmPoint;						trace("run ++++++++++++++++ X : " + _point.x + ", Y : " + _point.y);			//trace(_point);												var angle:Number = Math.atan2(_point.y - clip.y, _point.x - clip.x) * HypeMath.R2D;			var deltaAngle:Number = HypeMath.getDegreeDistance(clip.rotation, angle);						clip.rotation += deltaAngle * _turnEase + (Math.random() * _twitch * 2) - _twitch;			clip.x += Math.cos(clip.rotation * HypeMath.D2R) * _speed;			clip.y += Math.sin(clip.rotation * HypeMath.D2R) * _speed;		}						/**		 * The goal point the target is made to move towards		 */		public function get point():DisplayObject {			return _point;		}				public function set point(value:DisplayObject):void {			_point = value;		}				/**		 * Speed the target can travel		 */		public function get speed():Number {			return _speed;		}				public function set speed(speed:Number):void {			_speed = speed;		}				/**		 * Percentage the target can rotate toward it's goal in a given step		 */		public function get turnEase():Number {			return _turnEase;		}				public function set turnEase(turnEase:Number):void {			_turnEase = turnEase;		}				/**		 * Angular range of a random "twitch" added to each movement		 */		public function get twitch():Number {			return _twitch;		}				public function set twitch(twitch:Number):void {			_twitch = twitch;		}	}}